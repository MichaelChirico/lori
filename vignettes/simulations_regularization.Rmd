---
title: "simulations_no_covariates"
author: "Genevieve Robin"
date: "3/8/2018"
output: html_document
---
## Regularization parameter

In this document we explore the regularization path of lori and compare the two methods to select lambda: cross-validation and quantile universal threshold.

```{r cars}
#install.packages("lori")
library(lori)
library(mvtnorm)
library(gnm)
library(ggplot2)
library(svd)
library(FactoMineR)
m1 = 500
m2 = 200
m = min(m1, m2)
mu0 = rnorm(1)
mu0 = matrix(mu0, nrow = m1, ncol = m2)
alpha0 = rnorm(mean = 0, m1)
alpha0 = matrix(rep(alpha0, m2), nrow = m1, ncol = m2)
beta0 = rnorm(mean = 0, m2)
beta0 = matrix(rep(beta0, m1), nrow = m1, ncol = m2, byrow = TRUE)
X_null = mu0 + alpha0 + beta0
u = matrix(rnorm(m1 * m), nrow = m1, ncol = m)
u = qr(u)
u = qr.Q(u)
v = matrix(rnorm(m * m2), nrow = m2, ncol = m)
v = qr(v)
v = qr.Q(v)
q = 4
uu = u[, 1:q]
vv = v[, 1:q]
sigma = sum(svd(X_null)$d)*0.1
d = rep(sigma/q, q)
if (q > 1) {
  d = diag(d)
  theta0 = uu %*% d %*% t(vv)
} else {
  theta0 = d * uu %*% t(vv)
}
X_bar = X_null + theta0
Y = matrix(rpois(n = m1 * m2, exp(c(X_bar))), nrow = m1)
freq = c(t(Y))
row <- rep(1:m1, each = m2)
col <- rep(1:m2, m1)
mu <- row
nu <- col
row <- factor(row)
col <- factor(col)
indep_model = estimate_null(Y)
mu2=indep_model$mu
mu2=matrix(mu2, nrow=m1, ncol=m2)
alpha2=indep_model$alpha
alpha2=matrix(rep(alpha2,m2),nrow=m1,ncol=m2)
beta2=indep_model$beta
beta2=matrix(rep(beta2,m1), nrow=m1,ncol=m2,byrow=TRUE)
X_RC0=mu2+alpha2+beta2
error.gnm_0 = norm(as.matrix(X_RC0 - X_bar), type = "F")
deviance.gnm_0 = deviance(Y, X_RC0)

# Correspondence Analysis
ca = CA(Y)
X_ca=reconst(ca, ncp = 5)
error.ca = norm(X_ca-X_bar, type = "F")
deviance.ca = deviance(Y, X_ca)

# Plot histogram of the zero-thresholding statistic under H0
Y_null = matrix(rpois(n = m1 * m2, exp(c(X_null))), nrow = m1)
Y_null[Y_null<1]=1e-6
estim=estimate_null(Y_null)
mu=estim$mu
mu=matrix(mu, nrow=m1, ncol=m2)
alpha=estim$alpha
alpha=matrix(rep(alpha,m2),nrow=m1,ncol=m2)
beta=estim$beta
beta=matrix(rep(beta,m1), nrow=m1,ncol=m2,byrow=TRUE)
X_bar2=mu+alpha+beta
n=1e3 # number of Monte-Carlo replications
lambdas=rep(0,n)
for(i in 1:n)
{
  Y2=matrix(rpois(n=m1*m2,exp(c(X_bar2))), nrow=m1)
  Y2[Y2<=0]=1e-6
  estim2=estimate_null(Y2)
  mu2=estim2$mu
  mu2=matrix(mu2, nrow=m1, ncol=m2)
  alpha2=estim2$alpha
  alpha2=matrix(rep(alpha2,m2),nrow=m1,ncol=m2)
  beta2=estim2$beta
  beta2=matrix(rep(beta2,m1), nrow=m1,ncol=m2,byrow=TRUE)
  thresh=proj(Y2-exp(mu2+alpha2+beta2))
  lambdas[i]=(1/(m1*m2))*propack.svd(thresh,neig=1,opts=list(maxiter=1e5))$d
}
hist(lambdas)

proc = Sys.time()
lambda.q.H1 = lambda.QUT(Y, proj, 0.95, 1e3)
Sys.time() - proc


tol=1e-3 # Tolerance of lori. Can be increased or decreased 
# (depending on available time)
proc = Sys.time()
res.QUT = lori(Y, lambda.q.H1, proj, epsilon = tol, upper=2*log(max(Y)))
Sys.time() - proc

rank = res.QUT$rank
error.QUT = norm(as.matrix(c(t(res.QUT$X)) - c(t(X_bar))), type = "F")
deviance.QUT = deviance(Y, res.QUT$X)

df = data.frame(method = c("admm", "independence", "ca"), L2error = c(error.QUT, error.gnm_0, error.ca), deviance = c(deviance.QUT, deviance.gnm_0, deviance.ca))

write.table(df, file = file.path(getwd(), paste("results/", m1, "x", m2, "_q=", q, "_sigma=", sigma, ".txt", sep = "")), 
            row.names = TRUE, col.names = TRUE)
estim = estimate_null(Y)
mu = estim$mu
mu = matrix(mu, nrow = m1, ncol = m2)
alpha = estim$alpha
alpha = matrix(rep(alpha, m2), nrow = m1, ncol = m2)
beta = estim$beta
beta = matrix(rep(beta, m1), nrow = m1, ncol = m2, byrow = TRUE)
thresh = proj(Y - exp(mu + alpha + beta))
lambda.max = (1/(m1 * m2)) * propack.svd(thresh, neig = 1, opts = list(maxiter = 1e+05))$d 
lambda.grid = c(sort(exp(seq(log(lambda.max/1000), log(lambda.max), length.out = 20)), decreasing = T), lambda.q.H1)
res = list()

proc = Sys.time()
res[[1]] = lori(Y, lambda = lambda.max, proj,epsilon=tol)
Sys.time() - proc

for (k in 9:(length(lambda.grid) - 1)) {
  proc = Sys.time()
  res[[k]] = lori(Y, X.init=res[[k-1]]$X, U.init=res[[k-1]]$U, 
                    gamma.init=res[[k-1]]$gamma,lambda = lambda.grid[k],
                    proj,epsilon=tol)
  Sys.time() - proc
}

res[[length(lambda.grid)]] = res.QUT
save(res, file = paste("results/", m1, "x", m2, "_q=", q, "_sigma=", floor(sigma), ".Rdata", sep = ""))
rank = unlist(lapply(res, function(x) x$rank))
error = unlist(lapply(res, function(x) norm(as.matrix(c(t(x$X)) - c(t(X_bar))), type = "F")))
l = sort(lambda.grid[1:21])
idx = sort(lambda.grid[1:21], index.return = TRUE)
rank.sort = rank[idx$ix]
cols = rep("black", length(res))
cols[length(res)] = "red"
cols = cols[idx$ix]
min = min(c(error, df[2,2], df[3,2], df[4,2]), na.rm = TRUE) - 3
max = max(c(error, df[2,2], df[3,2], df[4,2]), na.rm = TRUE) + 3
pdf(filename = paste("results/", m1, "x", m2, "_q=", q, "_sigma=", floor(sigma), ".pdf", sep = ""))
plot(NA, xlim = c(min(lambda.grid), max(lambda.grid)), ylim = c(min, max), log = "x", ylab = "L2 error")
points(l, rep(df[2,2], 21), type = "b", col = "purple", pch = 15, cex = 1)
abline(v = lambda.grid[21], untf = FALSE, lty = 2, lwd = 2, col = "red")
points(l, rep(df[3,2], 21), type = "b", col = "blue", pch = 19, cex = 1)
#points(l, rep(df[4,2], 21), type = "b", col = "green", pch = 18, cex = 1)
points(l, error[idx$ix], col = cols, ylim = c(min, max), pch = 17, cex = 1, type = "b")
axis(3, at = l, labels = rank.sort)
dev.off()

```
